***************
*** 83,89 ****
    L->base = L->ci->base;
    luaF_close(L, L->base);  /* close eventual pending closures */
    luaD_seterrorobj(L, status, L->base);
-   L->nCcalls = L->baseCcalls;
    L->allowhook = 1;
    restore_stack_limit(L);
    L->errfunc = 0;
--- 83,89 ----
    L->base = L->ci->base;
    luaF_close(L, L->base);  /* close eventual pending closures */
    luaD_seterrorobj(L, status, L->base);
+   L->nCcalls = 0;
    L->allowhook = 1;
    restore_stack_limit(L);
    L->errfunc = 0;
***************
*** 419,440 ****
    lua_lock(L);
    if (L->status != LUA_YIELD && (L->status != 0 || L->ci != L->base_ci))
        return resume_error(L, "cannot resume non-suspended coroutine");
-   if (L->nCcalls >= LUAI_MAXCCALLS)
-     return resume_error(L, "C stack overflow");
    luai_userstateresume(L, nargs);
-   lua_assert(L->errfunc == 0);
-   L->baseCcalls = ++L->nCcalls;
    status = luaD_rawrunprotected(L, resume, L->top - nargs);
    if (status != 0) {  /* error? */
      L->status = cast_byte(status);  /* mark thread as `dead' */
      luaD_seterrorobj(L, status, L->top);
      L->ci->top = L->top;
    }
-   else {
-     lua_assert(L->nCcalls == L->baseCcalls);
      status = L->status;
-   }
-   --L->nCcalls;
    lua_unlock(L);
    return status;
  }
--- 419,434 ----
    lua_lock(L);
    if (L->status != LUA_YIELD && (L->status != 0 || L->ci != L->base_ci))
        return resume_error(L, "cannot resume non-suspended coroutine");
    luai_userstateresume(L, nargs);
+   lua_assert(L->errfunc == 0 && L->nCcalls == 0);
    status = luaD_rawrunprotected(L, resume, L->top - nargs);
    if (status != 0) {  /* error? */
      L->status = cast_byte(status);  /* mark thread as `dead' */
      luaD_seterrorobj(L, status, L->top);
      L->ci->top = L->top;
    }
+   else
      status = L->status;
    lua_unlock(L);
    return status;
  }
***************
*** 443,449 ****
  LUA_API int lua_yield (lua_State *L, int nresults) {
    luai_userstateyield(L, nresults);
    lua_lock(L);
-   if (L->nCcalls > L->baseCcalls)
      luaG_runerror(L, "attempt to yield across metamethod/C-call boundary");
    L->base = L->top - nresults;  /* protect stack slots below */
    L->status = LUA_YIELD;
--- 437,443 ----
  LUA_API int lua_yield (lua_State *L, int nresults) {
    luai_userstateyield(L, nresults);
    lua_lock(L);
+   if (L->nCcalls > 0)
      luaG_runerror(L, "attempt to yield across metamethod/C-call boundary");
    L->base = L->top - nresults;  /* protect stack slots below */
    L->status = LUA_YIELD;
