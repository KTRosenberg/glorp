#!/usr/local/bin/lua

local params = select(1, ...)
if not params then
  print("Stop running it from this directory, moron!")
  os.exit(1)
end

params.midname = params.longname:gsub("[^%w]", "")

require "luarocks.loader"
require "ursa"

clean_dirs = {}

local glop = ursa.embed{"glorp/Glop", "Den"}
local builddir_pre = "build/" .. glop.os
ursa.token.rule{"builddir", "!" .. builddir_pre, function () return builddir_pre end}
local builddir = builddir_pre .. "/"

local osd = assert(loadfile("glorp/Den_" .. glop.os .. ".lua")){name = params.name, longname = params.longname, midname = params.midname, glop = glop, builddir = builddir}

-- first we build the lua
local lua
local lua_headers = {}
do
  ursa.token.rule{"luajit_files", nil, function () return ursa.util.system{"cd glorp/luabuild/LuaJIT-1.1.5 && find src dynasm -type f"} end}
  local copied = {}
  for k in ursa.token{"luajit_files"}:gmatch("([^\n]+)") do
    table.insert(copied, ursa.rule{builddir .. "luajit/" .. k, "glorp/luabuild/LuaJIT-1.1.5/" .. k, ursa.util.system_template{"cp $SOURCE $TARGET"}})
  end
  
  local luaobjects = {}
  for k in ("lapi lcode ldebug ldo ldump lfunc lgc llex lmem lobject lopcodes lparser lstate lstring ltable ltm lundump lvm lzio lcoco ljit_core ljit_mem ljit_dasm ljit_backend lauxlib lbaselib ldblib liolib lmathlib loslib ltablib lstrlib loadlib ljitlib linit"):gmatch("([^ ]+)") do  -- yes okay hardcoded shut up
    table.insert(luaobjects, (builddir .. "luajit/src/%s.o"):format(k))
  end

  do
    local buildtype
    if glop.os == "cygwin" then buildtype = "cygwin" end
    if glop.os == "osx" then buildtype = "macosx" end
    assert(buildtype)
    ursa.rule{luaobjects, copied, ursa.util.system_template{("cd %sluajit/src && nice make -j5 %s"):format(builddir, buildtype)}}
  end
  ursa.rule{builddir .. "lua/lib/liblua.a", luaobjects, ursa.util.system_template{"ar rcs $TARGET $SOURCES"}} -- woneder if this'll work right under cygwin

  local luabuilds = {builddir .. "lua/lib/liblua.a"}
  
  for k in ("lua.h lauxlib.h lualib.h luaconf.h"):gmatch("([^ ]+)") do
    table.insert(lua_headers, ursa.rule{builddir .. "lua/include/" .. k, "glorp/luabuild/LuaJIT-1.1.5/src/" .. k, ursa.util.system_template{"cp $SOURCE $TARGET"}})
  end
  table.insert(lua_headers, ursa.rule{builddir .. "lua/include/lua.hpp", "glorp/luabuild/LuaJIT-1.1.5/etc/lua.hpp", ursa.util.system_template{"cp $SOURCE $TARGET"}})
  
  local luabindobj = {}
  local luabindroot = "glorp/luabuild/luabind-0.9ish"
  local luabindpath = luabindroot .. "/src/"
  ursa.token.rule{"luabind_source_files", nil, function () return ursa.util.system{("cd %s && ls *.cpp"):format(luabindpath)} end}
  for k in ursa.token{"luabind_source_files"}:gmatch("([^\n]+)") do
    table.insert(luabindobj, ursa.rule{builddir .. "luabind/" .. k:gsub(".cpp", ".o"), {luabuilds, luabindpath .. k}, ursa.util.system_template{("nice #CC -O2 -o $TARGET -c %s -Iglorp/%s -I#builddir/lua/include -Iglorp/luabuild/luabind-0.9ish #CXXFLAGS -g"):format(luabindpath .. k, luabindroot)}})
  end
  
  lua = builddir .. "lua/lib/libluabind.a"
  ursa.rule{lua, luabindobj, ursa.util.system_template{"ar rcs $TARGET $SOURCES"}}
  
  ursa.token.rule{"luabind_headers", nil, function () return ursa.util.system{("cd %s/luabind && find . -type f | sed s*\\\\./**"):format(luabindroot)} end}
  for item in ursa.token{"luabind_headers"}:gmatch("([^\n]+)") do
    local dest = builddir .. "lua/include/luabind/" .. item
    ursa.rule{dest, luabindroot .. "/luabind/" .. item, ursa.util.system_template{"cp $SOURCE $TARGET"}}
    table.insert(lua_headers, dest)
  end
end

ursa.token.rule{"curl_link", nil, function () return "-lcurl" end} --"curl-config --libs" seems to cause issues

ursa.token.rule{"version", nil, ("git describe --match %s-* | sed s/%s-//"):format(params.name, params.name), always_rebuild = true}

ursa.rule{"version.cpp", "#version", function ()
  print("Writing file version.cpp")
  local fil = io.open("version.cpp", "w")
  fil:write(([[extern const char game_version[] = "%s";]]):format(ursa.token{"version"}) .. "\n")
  fil:write(([[extern const char game_fullname[] = "%s";]]):format(params.longname) .. "\n")
  fil:write(([[extern const char game_midname[] = "%s";]]):format(params.midname) .. "\n")
  fil:write(([[extern const char game_slug[] = "%s";]]):format(params.name) .. "\n")
  fil:close()
end}

local buildables = {
  [params.name] = {corefiles = "main version", glorpfiles = "core debug debug_911_on os util parse args init perfbar", cfiles = "glorp/LuaGL", resources = "resource"},
  ["reporter"] = {corefiles = "version", glorpfiles = "reporter_main debug_911_off os_ui os debug util parse args init"},
}

local depsed = {}

local function build_object(src, prefix, compiler)
  local cli = ("%s -O2 -Wall -Wno-sign-compare -Wno-uninitialized -g -DDPRINTF_MARKUP -I%slua/include %s %s "):format(compiler or ursa.token{"CC"}, builddir, ursa.token{"CXXFLAGS"}, src)
  if not depsed[src] then
    local function make_dependencies(srcfile)
      local deps = ursa.util.system{cli .. "-MM"}
      deps = deps:match("^.*: (.*)$")
      
      local dependencies = {}
      for file in deps:gmatch("([^ \n\t]+)") do
        if file ~= "\\" then
          table.insert(dependencies, file)
        end
      end
      
      return dependencies
    end
    
    local depend = src .. " dependencies"
    
    ursa.token.rule{depend, {glop.headers, lua_headers, ursa.util.token_deferred{depend, default = src}}, function () return make_dependencies(cpp) end}
    depsed[src] = ursa.util.token_deferred{depend}
  end
  
  local dst = prefix .. "/" .. src:gsub("%.cpp", ".o"):gsub("%.c", ".o")
  ursa.rule{dst, {src, lua_headers, glop.headers, depsed[src]}, ursa.util.system_template{"nice glorp/ewrap $TARGET " .. cli .. "-o $TARGET -c"}}
  return dst
end

local function build_program(name)
  local item = buildables[name]
  assert(item)
  
  local prefix = builddir .. name
  
  local objs = {}
  
  for k in (item.corefiles or ""):gmatch("([^%s]+)") do
    table.insert(objs, build_object(k .. ".cpp", prefix))
  end
  for k in (item.glorpfiles or ""):gmatch("([^%s]+)") do
    table.insert(objs, build_object("glorp/" .. k .. ".cpp", prefix))
  end
  for k in (item.cfiles or ""):gmatch("([^%s]+)") do
    table.insert(objs, build_object(k .. ".c", prefix, "gcc"))
  end
  
  if glop.os == "cygwin" then
    for k in (item.resources or ""):gmatch("([^%s]+)") do
      local dst = (builddir .. "glorp/%s.res"):format(k)
      ursa.rule{dst, "glorp/" .. k .. ".rc", ursa.util.system_template{"nice windres $SOURCE -O coff -o $TARGET"}}
      table.insert(objs, dst)
    end
  end
  
  table.insert(objs, lua[1])
  
  local dst = builddir .. name .. osd.extension
  ursa.rule{dst, {objs, glop.lib, lua, "#curl_link"}, ursa.util.system_template{"nice glorp/ewrap $TARGET #CC -O2 -o $TARGET -g $SOURCES -L#builddir/lua/lib -lluabind -lm -llua -lz -lpng #curl_link #LDFLAGS"}}
  return dst
end

local mainprog = build_program(params.name)
local reporter = build_program("reporter")

local runnable = osd.create_runnable{mainprog = mainprog, reporter = reporter}

ursa.command{ursa.command.default, runnable.deps}
ursa.command{"run", runnable.deps, runnable.cli .. " debug"}
ursa.command{"runclean", runnable.deps, runnable.cli}

-- here is where we're generating the file list for packaging
do
  local data_deps = {}
  
  local function copy_a_lot(token, destprefix, sourceprefix)
    ursa.token.rule{token .. "_copy", "#" .. token .. "_files", function ()
        local data_items = {}
        for k in ursa.token{token .. "_files"}:gmatch("[^%s]+") do
          local ext = k:match("^.*%.([^%.]+)$")
          
          local dst = destprefix .. k
          local src = sourceprefix .. k
          
          local cli
          if ext == "png" then
            cli = "pngcrush -brute -rem alla -cc $SOURCE $TARGET"
          elseif ext == "wav" then
            dst = dst:gsub("%.wav", ".ogg")
            cli = "oggenc --downmix -q 5 -o $TARGET $SOURCE || oggenc -q 6 -o $TARGET $SOURCE"
          else
            cli = "cp $SOURCE $TARGET"
          end
          
          table.insert(data_items, {src = src, dst = dst, cli = cli})
        end
        return data_items
      end}
    return token .. "_copy"
  end

  -- replicate the data structure in
  ursa.token.rule{"data_files", nil, "cd data && find . -type f | sed s*\\\\./**", always_rebuild = true}
  table.insert(data_deps, copy_a_lot("data", "data/", "data/"))

  ursa.token.rule{"stock_files", nil, "cd glorp/resources && ls mandible_games.png", always_rebuild = true}
  table.insert(data_deps, copy_a_lot("stock", "data/", "glorp/resources/"))

  -- JIT lua files
  ursa.token.rule{"jit_files", nil, "cd glorp/resources/jit && ls"}
  table.insert(data_deps, copy_a_lot("jit", "data/jit/", "glorp/resources/jit/"))

  -- Lua files in Glorp
  ursa.token.rule{"luaglorp_files", nil, "cd glorp && ls *.lua | grep -v Den"}
  table.insert(data_deps, copy_a_lot("luaglorp", "data/", "glorp/"))

  -- Lua files and font files in our core
  ursa.token.rule{"core_files", nil, "ls *.lua *.ttf"}
  table.insert(data_deps, copy_a_lot("core", "", ""))

  ursa.token.rule{"datafiles", data_deps, function ()
    local chunks = {}
    for _, v in pairs(data_deps) do
      for _, tv in pairs(ursa.token{v}) do
        table.insert(chunks, tv)
      end
    end
    return chunks
  end}
  
  ursa.token.rule{"outputprefix", "#version", function ()
    return ("%s-%s"):format(params.midname, ursa.token{"version"})
  end}
end

ursa.command{"package", osd.installers("datafiles")}

ursa.command{"clean", function ()
  ursa.util.clean()
  for _, v in ipairs(clean_dirs) do
    os.remove(v)
  end
end}

ursa.build{unpack(params.targets)}
