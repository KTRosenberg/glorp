#!/usr/local/bin/lua

local params = select(1, ...)
if not params then
  print("Stop running it from this directory, moron!")
  os.exit(1)
end

params.midname = params.longname:gsub("[^%w]", "")

require "luarocks.loader"
require "ursa"

clean_dirs = {}

local glop
if true then
  glop = ursa.embed{"glorp/Glop", "Den", {{platform = params.platform}}}
else
  glop = {os = params.platform, headers = {}, lib = {}}
end

local platform = params.platform or glop.os

local builddir_pre = "build/" .. platform
ursa.token.rule{"builddir", "!" .. builddir_pre, function () return builddir_pre end}
local builddir = builddir_pre .. "/"

local osd = assert(loadfile("glorp/Den_" .. platform .. ".lua")){name = params.name, longname = params.longname, midname = params.midname, glop = glop, builddir = builddir}

-- first we build the lua
local lua
local lua_headers = {}
do
  do
    if not osd.noluajit then
      local path = "glorp/luabuild/LuaJIT-2.0.0-b2p1/"
      ursa.token.rule{"lua_files", "!" .. path, function () return ursa.util.system{("cd %s && find . -type f | sed s*\\\\./**"):format(path)} end}
      local copied = {}
      for k in ursa.token{"lua_files"}:gmatch("([^\n]+)") do
        table.insert(copied, ursa.rule{builddir .. "luabuild/" .. k, path .. k, ursa.util.system_template{"cp $SOURCE $TARGET"}})
      end
      table.insert(copied, ursa.rule{builddir .. "luabuild/src/Makefile", builddir .. "luabuild/src/Makefile." .. platform, ursa.util.system_template{"cp $SOURCE $TARGET"}})
      
      ursa.rule{builddir .. "luabuild/src/libluajit.a", copied, ursa.util.system_template{("cd %s && make -j5"):format(builddir .. "luabuild")}}
      ursa.rule{builddir .. "lua/lib/liblua.a", builddir .. "luabuild/src/libluajit.a", ursa.util.system_template{"cp $SOURCE $TARGET"}}
      
      -- luajit includes it in src
      table.insert(lua_headers, ursa.rule{builddir .. "lua/include/lua.hpp", builddir .. "luabuild/src/lua.hpp", ursa.util.system_template{"cp $SOURCE $TARGET"}})
      table.insert(lua_headers, ursa.rule{builddir .. "lua/include/luajit.h", builddir .. "luabuild/src/luajit.h", ursa.util.system_template{"cp $SOURCE $TARGET"}})
    else
      local files = "lapi lcode ldebug ldo ldump lfunc lgc llex lmem lobject lopcodes lparser lstate lstring ltable ltm lundump lzio lcoco linit lauxlib lbaselib ldblib liolib lmathlib loslib ltablib lstrlib loadlib lvm"
      local path = "glorp/luabuild/lua-5.1.4/"
      
      ursa.token.rule{"lua_files", "!" .. path, function () return ursa.util.system{("cd %s && find src -type f && (find dynasm -type f || true) "):format(path)} end}
      local copied = {}
      for k in ursa.token{"lua_files"}:gmatch("([^\n]+)") do
        table.insert(copied, ursa.rule{builddir .. "luabuild/" .. k, path .. k, ursa.util.system_template{"cp $SOURCE $TARGET"}})
      end
      
      local luaobjects = {}
      for k in files:gmatch("([^ ]+)") do  -- yes okay hardcoded shut up
        table.insert(luaobjects, ursa.rule{builddir .. "luabuild/src/" .. k .. ".o", copied, ursa.util.system_template{"#CC -O3 -fomit-frame-pointer #LUA_FLAGS -I#builddir/luabuild/dynasm -Wall -x c -c -o $TARGET #builddir/luabuild/src/" .. k .. ".c"}})
      end

      ursa.rule{builddir .. "lua/lib/liblua.a", luaobjects, ursa.util.system_template{"ar rcs $TARGET $SOURCES"}} -- wonder if this'll work right under cygwin
      
      -- base lua includes it in etc
      table.insert(lua_headers, ursa.rule{builddir .. "lua/include/lua.hpp", builddir .. "luabuild/etc/lua.hpp", ursa.util.system_template{"cp $SOURCE $TARGET"}})
    end
  end

  local luabuilds = {builddir .. "lua/lib/liblua.a"}
  
  for k in ("lua.h lauxlib.h lualib.h luaconf.h"):gmatch("([^ ]+)") do
    table.insert(lua_headers, ursa.rule{builddir .. "lua/include/" .. k, builddir .. "luabuild/src/" .. k, ursa.util.system_template{"cp $SOURCE $TARGET"}})
  end
  
  
  local luabindobj = {}
  local luabindroot = "glorp/luabuild/luabind-0.9ish"
  local luabindpath = luabindroot .. "/src/"
  ursa.token.rule{"luabind_source_files", nil, function () return ursa.util.system{("cd %s && ls *.cpp"):format(luabindpath)} end}
  for k in ursa.token{"luabind_source_files"}:gmatch("([^\n]+)") do
    table.insert(luabindobj, ursa.rule{builddir .. "luabind/" .. k:gsub(".cpp", ".o"), {luabuilds, luabindpath .. k}, ursa.util.system_template{("nice #CC -O2 -o $TARGET -c %s -Iglorp/%s -I#builddir/lua/include -Iglorp/luabuild/luabind-0.9ish -Iglorp/libs/boost #CXXFLAGS -g"):format(luabindpath .. k, luabindroot)}})
  end
  
  lua = builddir .. "lua/lib/libluabind.a"
  ursa.rule{lua, luabindobj, ursa.util.system_template{"ar rcs $TARGET $SOURCES"}}
  
  ursa.token.rule{"luabind_headers", nil, function () return ursa.util.system{("cd %s/luabind && find . -type f | sed s*\\\\./**"):format(luabindroot)} end}
  for item in ursa.token{"luabind_headers"}:gmatch("([^\n]+)") do
    local dest = builddir .. "lua/include/luabind/" .. item
    ursa.rule{dest, luabindroot .. "/luabind/" .. item, ursa.util.system_template{"cp $SOURCE $TARGET"}}
    table.insert(lua_headers, dest)
  end
end

if not osd.nocurl then
  token_literal("curl_link", "-lcurl")
else
  token_literal("curl_link", "")
end

ursa.token.rule{"version", nil, ("git describe --match %s-* | sed s/%s-//"):format(params.name, params.name), always_rebuild = true}

ursa.rule{"version.cpp", "#version", function ()
  print("Writing file version.cpp")
  local fil = io.open("version.cpp", "w")
  fil:write(([[extern const char game_version[] = "%s";]]):format(ursa.token{"version"}) .. "\n")
  fil:write(([[extern const char game_fullname[] = "%s";]]):format(params.longname) .. "\n")
  fil:write(([[extern const char game_midname[] = "%s";]]):format(params.midname) .. "\n")
  fil:write(([[extern const char game_slug[] = "%s";]]):format(params.name) .. "\n")
  fil:write(([[extern const char game_platform[] = "%s";]]):format(platform) .. "\n")
  fil:close()
end}

local buildables = {
  [params.name] = {corefiles = "main version", glorpfiles = "core debug debug_911_on os util parse args init perfbar LuaGL_common " .. (osd.gles and "LuaGLES" or "LuaGL LuaGL_ext"), cfiles = osd.gles and "" or "glorp/GLee", mmfiles = osd.gles and "main_iphone" or "", resources = "resource"},
  ["reporter"] = {corefiles = "version", glorpfiles = "reporter_main debug_911_off os_ui os debug util parse args init"},
}

local depsed = {}

local function build_object(src, prefix, compiler)
  local cli = ("%s -O2 -Wall -Wno-sign-compare -Wno-uninitialized -g -DDPRINTF_MARKUP -Iglorp/libs/boost -I%slua/include %s %s "):format(compiler or ursa.token{"CC"}, builddir, ursa.token{"CXXFLAGS"}, src)
  if not depsed[src] then
    local function make_dependencies(srcfile)
      local deps = ursa.util.system{cli .. "-MM"}
      deps = deps:match("^.*: (.*)$")
      
      local dependencies = {}
      for file in deps:gmatch("([^%s]+)") do
        if file ~= "\\" then
          table.insert(dependencies, file)
        end
      end
      
      return dependencies
    end
    
    local depend = src .. " dependencies"
    
    ursa.token.rule{depend, {glop.headers, lua_headers, ursa.util.token_deferred{depend, default = src}}, function () return make_dependencies(cpp) end}
    depsed[src] = ursa.util.token_deferred{depend}
  end
  
  local dst = prefix .. "/" .. src:gsub("%.cpp", ".o"):gsub("%.c", ".o"):gsub("%.mm", ".o")
  ursa.rule{dst, {src, lua_headers, glop.headers, depsed[src]}, ursa.util.system_template{"nice glorp/ewrap $TARGET " .. cli .. "-o $TARGET -c"}}
  return dst
end

local function build_program(name)
  local item = buildables[name]
  assert(item)
  
  local prefix = builddir .. name
  
  local objs = {}
  
  for k in (item.corefiles or ""):gmatch("([^%s]+)") do
    table.insert(objs, build_object(k .. ".cpp", prefix))
  end
  for k in (item.glorpfiles or ""):gmatch("([^%s]+)") do
    table.insert(objs, build_object("glorp/" .. k .. ".cpp", prefix))
  end
  for k in (item.cfiles or ""):gmatch("([^%s]+)") do
    table.insert(objs, build_object(k .. ".c", prefix, "gcc"))
  end
  for k in (item.mmfiles or ""):gmatch("([^%s]+)") do
    table.insert(objs, build_object("glorp/" .. k .. ".mm", prefix, "g++ -x objective-c++"))
  end
  
  if platform == "cygwin" then
    for k in (item.resources or ""):gmatch("([^%s]+)") do
      local dst = (builddir .. "glorp/%s.res"):format(k)
      ursa.rule{dst, "glorp/" .. k .. ".rc", ursa.util.system_template{"nice windres $SOURCE -O coff -o $TARGET"}}
      table.insert(objs, dst)
    end
  end
  
  table.insert(objs, lua[1])
  
  local dst = builddir .. name .. osd.extension
  ursa.rule{dst, {objs, glop.lib, lua, "#curl_link"}, ursa.util.system_template{"nice glorp/ewrap $TARGET #CC -O2 -o $TARGET -g $SOURCES -L#builddir/lua/lib -lluabind -lm -llua -lz -lpng #curl_link #LDFLAGS"}}
  return dst
end

local mainprog = build_program(params.name)
local reporter = build_program("reporter")

ursa.token.rule{"oggquality", "!6", function () return "6" end}  -- heh.

-- here is where we're generating the file list for packaging
do
  local data_deps = {}
  
  local converts = {}
  function converts.png(dst)
    return "pngcrush -brute -rem alla -cc $SOURCE $TARGET"
  end
  function converts.wav(dst)
    return "oggenc --downmix -q #oggquality -o $TARGET $SOURCE || oggenc -q #oggquality -o $TARGET $SOURCE", dst:gsub("%.wav", ".ogg")
  end
  function converts.flac(dst)
    return [[(#FLAC -d $SOURCE -c | oggenc --downmix -q #oggquality -o $TARGET -) || (#FLAC -d $SOURCE -c | oggenc -q #oggquality -o $TARGET -)]], dst:gsub("%.flac", ".ogg")
  end
  if osd.build_overrides then
    for k, v in pairs(osd.build_overrides) do
      converts[k] = v
    end
  end
  
  local function copy_a_lot(token, destprefix, sourceprefix)
    ursa.token.rule{token .. "_copy", "#" .. token .. "_files", function ()
        local data_items = {}
        for k in ursa.token{token .. "_files"}:gmatch("[^%s]+") do
          local ext = k:match("^.*%.([^%.]+)$")
          
          local dst = destprefix .. k
          local src = sourceprefix .. k
          
          local odst = dst
          
          local cli
          
          if converts[ext] then
            cli, dst = converts[ext](dst)
          end
          
          dst = dst or odst
          
          if not cli then
            cli = "cp $SOURCE $TARGET"
          end
          
          table.insert(data_items, {src = src, dst = dst, cli = cli})
        end
        return data_items
      end, always_rebuild = true}
    return "#" .. token .. "_copy"
  end

  -- replicate the data structure in
  ursa.token.rule{"data_files", nil, "cd data && find . -type f | sed s*\\\\./**", always_rebuild = true}
  table.insert(data_deps, copy_a_lot("data", "data/", "data/"))

  ursa.token.rule{"stock_files", nil, "cd glorp/resources && ls mandible_games.png", always_rebuild = true}
  table.insert(data_deps, copy_a_lot("stock", "data/", "glorp/resources/"))

  -- JIT lua files
  ursa.token.rule{"jit_files", nil, "cd glorp/resources/jit && ls"}
  table.insert(data_deps, copy_a_lot("jit", "data/jit/", "glorp/resources/jit/"))

  -- Lua files in Glorp
  ursa.token.rule{"luaglorp_files", nil, "cd glorp && ls *.lua | grep -v Den"}
  table.insert(data_deps, copy_a_lot("luaglorp", "data/", "glorp/"))

  -- Lua files and font files in our core
  ursa.token.rule{"core_files", nil, "ls *.lua *.ttf"}
  table.insert(data_deps, copy_a_lot("core", "", ""))

  ursa.token.rule{"datafiles", data_deps, function ()
    local chunks = {}
    for _, v in pairs(data_deps) do
      for _, tv in pairs(ursa.token{v:sub(2)}) do
        table.insert(chunks, tv)
      end
    end
    return chunks
  end}
  
  ursa.token.rule{"outputprefix", "#version", function ()
    return ("%s-%s"):format(params.midname, ursa.token{"version"})
  end}
end

local runnable = osd.create_runnable{mainprog = mainprog, reporter = reporter}

ursa.command{ursa.command.default, runnable.deps}

if osd.no_cli_params then
  ursa.command{"run", runnable.deps, runnable.cli}
else
  ursa.command{"run", runnable.deps, runnable.cli .. " debug"}
  ursa.command{"runclean", runnable.deps, runnable.cli}
end

ursa.command{"package", osd.installers("datafiles")}

ursa.command{"clean", function ()
  ursa.util.clean()
  for _, v in ipairs(clean_dirs) do
    os.remove(v)
  end
end}

ursa.build{unpack(params.targets)}
